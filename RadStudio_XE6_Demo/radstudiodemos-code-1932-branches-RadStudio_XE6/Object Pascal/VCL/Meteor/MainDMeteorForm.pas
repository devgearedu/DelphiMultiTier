unit MainDMeteorForm;
//--------------------------------------------------------------------------
// Copyright (c) 1995-2010 Embarcadero Technologies, Inc.

// You may only use this software if you are an authorized licensee
// of Delphi, C++Builder or RAD Studio (Embarcadero Products).
// This software is considered a Redistributable as defined under
// the software license agreement that comes with the Embarcadero Products
// and is subject to that software license agreement.
//--------------------------------------------------------------------------
interface

uses
  Windows, Messages, SysUtils, Variants, Classes, Graphics, Controls, Forms,
  Dialogs, ExtCtrls, SpriteUnit;

type
  TDMeteorForm = class(TForm)
    PaintBox1: TPaintBox;
    Timer1: TTimer;
    procedure Timer1Timer(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure FormKeyUp(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure FormKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
    procedure PaintBox1Paint(Sender: TObject);
    procedure FormDestroy(Sender: TObject);
  private
      gwidth, gheight : integer;

      sprites : TSpriteList;       // list of all the sprites on the screen

      ship : TShip;         // a seperate pointer to the ship, so we can adjust
							// it's speed, etc.  the ship is also inserted into
							// the sprite list

      scoreDisplay : TSprMessage; // pointer to the score object, so we can update it


       rotateLeft,    // flags set when the player presses keys
			 rotateRight, thrust, fire : boolean;

       score, shipsLeft, newShipCountdown : integer;     // countdown to new player ship appearing
       gameOver         : boolean;
       SpeedyClientRect : TRect;
       shotDelay,shotDelayReset : integer;  // used to limit how many shots can be fired
    procedure InitGameSettings;
    procedure InitGameGraphics;
    procedure DrawGameObjects;
  public
    { Public declarations }
  end;

var
  DMeteorForm: TDMeteorForm;

implementation
const
  METEOR_COUNT = 8;

{$R *.dfm}

procedure TDMeteorForm.InitGameSettings;
var
  i : integer;
  temp : TSize;
begin
  gwidth   := DisplaySize.cx;
  gheight  := DisplaySize.cy;
  ClientHeight := gheight;
  ClientWidth  := gwidth;
  temp.cx := random(5)-3;
  temp.cy := random(5)-3;
  sprites := TSpriteList.Create;

  for i := 0 to  METEOR_COUNT do
	   sprites.Add( TMeteor.Create( Point( random(gwidth), random(gheight) ),
										 temp,3, 3 ));
  ship := TShip.Create( Point( gwidth div 2, gheight div 2 ) );
  scoreDisplay := TSprMessage.Create(Point(5,5));
  scoreDisplay.SetText('');
  sprites.Add( ship );
  sprites.Add( scoreDisplay );
  rotateLeft  := false;
  rotateRight := false;
  thrust      := false;
  fire        := false;
end;



procedure TDMeteorForm.PaintBox1Paint(Sender: TObject);
begin
  DrawGameObjects;
end;

procedure TDMeteorForm.FormKeyDown(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  case (Key) of
    VK_LEFT:
      rotateLeft := true;
    VK_UP:
      thrust := true;
    VK_RIGHT:
      rotateRight := true;
    VK_SPACE:
      fire := true;
  end;
end;

procedure TDMeteorForm.FormKeyUp(Sender: TObject; var Key: Word;
  Shift: TShiftState);
begin
  case (Key) of
    VK_LEFT:
      rotateLeft := false;
    VK_UP:
      thrust := false;
    VK_RIGHT:
      rotateRight := false;
    VK_SPACE:
     begin
      fire := false;
      shotDelay := 0;
     end;
  end;
end;

procedure TDMeteorForm.DrawGameObjects;
var
  points    : integer;
  aPoint : TPoint;
begin


  // ExtTextOut is faster than using FillRect
  PaintBox1.Canvas.FillRect(SpeedyClientRect);


  // draw all the sprites to the memory DC, then update them all
  sprites.DrawAll( PaintBox1.Canvas );

  // UpdateAll returns the number of points generated by bullets hitting
  // meteors.  If it returns a negative number, it means the ship was hit

  points := sprites.UpdateAll();

  if (points < 0) then
  begin  // ship was hit
    ship.Explode();
    ship := nil;
    points := 0;
    newShipCountdown := 50;
    dec(shipsLeft);
    if (shipsLeft <= 0) then
      gameOver := true;
  end;


  // if the ship was destroyed, adjust countdown to new ship

  if (newShipCountdown > 0) then
  begin
    Dec(newShipCountdown);
    if (newShipCountdown = 0) then
    begin
        aPoint :=  Point( gwidth div 2, gheight div 2 );
      ship :=  TShip.Create(aPoint);
      sprites.Add( ship );
    end;
  end;

  // depending on what keys the user has pressed, adjust the
  // ship position/thrust/etc

  if (Assigned(ship)) then
  begin
    if (rotateLeft) then ship.Rotate( 15 );
    if (rotateRight) then ship.Rotate( -15 );

    if (thrust) then
      ship.AddThrust( +1 )
    else
      ship.AddThrust( -1 );

    // if the user is holding the spacebar, countdown to the next
    // shot

    if ((fire) and ( shotDelay = 0)) then
    begin
      sprites.Add( ship.CreateNewShot );
      shotDelay := shotDelayReset;
    end;
    if (shotDelay <> 0) then  Dec(shotDelay);
  end;

  // update the score display

  if (points <> 0) then
  begin
	  inc(score,points);
	  scoreDisplay.SetText(Format('%8d %s',[score,StringOfChar('*',shipsLeft)]));
  end;
end;


procedure TDMeteorForm.InitGameGraphics;
begin
  // set the pen color to green, and the textbackground color to black
	PaintBox1.Canvas.Pen.Color   :=  clGreen;
	PaintBox1.Canvas.Brush.Color :=  clBlack;
  // initialize a timer to run the game
  shotDelay      := 5;
  shotDelayReset := 5;
  score       := 0;
  shipsLeft   := 4;
  gameOver    := false;
  newShipCountdown := 0;
  SpeedyClientRect := ClientRect;
end;


procedure TDMeteorForm.FormCreate(Sender: TObject);
begin
  InitGameSettings();
	InitGameGraphics();
	DoubleBuffered := true;
end;

procedure TDMeteorForm.FormDestroy(Sender: TObject);
begin
 FreeAndNil(sprites);
end;

procedure TDMeteorForm.Timer1Timer(Sender: TObject);
begin
 PaintBox1.Invalidate;
end;

end.
